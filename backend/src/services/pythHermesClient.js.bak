import { HermesClient } from '@pythnetwork/hermes-client';
import config from '../config/appConfig.js';
import logger from '../utils/logger.js';

// Constants for WebSocket connection
const WS_RECONNECT_DELAY = 1000;
const MAX_RECONNECT_ATTEMPTS = 5;
const PING_INTERVAL = 30000; // 30 seconds

class PythHermesClient {
    constructor() {
        // Check if Hermes URL is configured
        if (!config.hermesUrl) {
            logger.error('❌ HERMES_URL not configured. Please set HERMES_URL in your .env file');
            this.client = null;
            this.latestPrices = new Map();
            this.priceHistory = new Map();
            this.isStreaming = false;
            this.isConfigured = false;
            return;
        }
        
        this.client = new HermesClient(config.hermesUrl);
        this.latestPrices = new Map();
        this.priceHistory = new Map();
        this.isStreaming = false;
        this.isConfigured = true;
    }


    /**
     * Start streaming live pricess for free
     */
    async startPriceStream() {
        if (!this.isConfigured) {
            logger.error('❌ Cannot start price stream: Pyth client not properly configured');
            return;
        }
        
        if(this.isStreaming) {
            logger.warn('Price stream already running');
            return;
        }
        this.isStreaming = true;
        const priceIds = Object.values(config.priceIds).filter(id => id); // Filter out undefined IDs

        if (priceIds.length === 0) {
            logger.error('❌ No valid price IDs configured. Please set BTC_PRICE_ID, ETH_PRICE_ID, SOL_PRICE_ID in your .env file');
            this.isStreaming = false;
            return;
        }

        logger.info(` LIVE: Starting Pyth price stream for ${priceIds.length} feeds (FREE!)`);
        
        try {
            // Subscribe to price updates
            const priceFeeds = this.client.getPriceUpdatesStream(priceIds);
            
            // Handle the stream properly
            if (priceFeeds && typeof priceFeeds[Symbol.asyncIterator] === 'function') {
                for await (const priceUpdate of priceFeeds) {
                    if (priceUpdate && priceUpdate.parsed) {
                        for (const priceFeed of priceUpdate.parsed) {
                            this.processPriceUpdate(priceFeed);
                        }
                    }
                }
            } else {
                // Fallback: use polling if streaming is not available
                logger.warn('Streaming not available, falling back to polling');
                this.startPolling();
            }
        } catch (error) {
            logger.error(`Error in price stream: ${error.message}`);
            this.isStreaming = false;
            
            // Retry after 5 seconds
            setTimeout(() => this.startPriceStream(), 100);
        }
    }
    
    /**
     * Fallback polling method when streaming is not available
     */
    async startPolling() {
        const priceIds = Object.values(config.priceIds);
        logger.info('Starting price polling as fallback');
        
        const pollInterval = setInterval(async () => {
            if (!this.isStreaming) {
                clearInterval(pollInterval);
                return;
            }
            
            try {
                for (const priceId of priceIds) {
                    await this.fetchLatestPrice(priceId);
                }
            } catch (error) {
                logger.error(`Error in polling: ${error.message}`);
            }
        }, 100); // Poll every 100ms seconds
    }
    
    /**
     * Process incoming price update
     */
    processPriceUpdate(priceFeed) {
        const price = parseFloat(priceFeed.price.price) / Math.pow(10, Math.abs(priceFeed.price.expo));
        const confidence = parseFloat(priceFeed.price.conf) / Math.pow(10, Math.abs(priceFeed.price.expo));
        
        const priceData = {
            id: priceFeed.id,
            price: price,
            confidence: confidence,
            publishTime: priceFeed.price.publish_time,
            prevPublishTime: priceFeed.prev_publish_time,
            expo: priceFeed.price.expo,
            timestamp: Date.now()
        };
        
        // Store latest price
        this.latestPrices.set(priceFeed.id, priceData);
        
        // Store in history (keep last 100)
        if (!this.priceHistory.has(priceFeed.id)) {
            this.priceHistory.set(priceFeed.id, []);
        }
        
        const history = this.priceHistory.get(priceFeed.id);
        history.push(priceData);
        
        if (history.length > 100) {
            history.shift();
        }
        
        // Find asset name
        const assetName = Object.keys(config.priceIds).find(
            key => config.priceIds[key] === priceFeed.id
        );
        
        logger.info(` ${assetName || priceFeed.id.slice(0, 8)}: $${price.toFixed(2)} (±$${confidence.toFixed(2)})`);
    }
    
    /**
     * Get latest price for a specific feed (from memory - FREE!)
     */
    getLatestPrice(priceId) {
        return this.latestPrices.get(priceId) || null;
    }
    
    /**
     * Get price history for analysis
     */
    getPriceHistory(priceId, limit = 100) {
        const history = this.priceHistory.get(priceId) || [];
        return history.slice(-limit);
    }
    
    /**
     * Get all latest prices
     */
    getAllLatestPrices() {
        const prices = {};
        for (const [assetName, priceId] of Object.entries(config.priceIds)) {
            prices[assetName] = this.latestPrices.get(priceId);
        }
        return prices;
    }
    
    /**
     * Fetch single price update (fallback method)
     */
    async fetchLatestPrice(priceId) {
        try {
            const priceFeeds = await this.client.getLatestPriceUpdates([priceId]);
            
            if (priceFeeds && priceFeeds.parsed && priceFeeds.parsed.length > 0) {
                const priceFeed = priceFeeds.parsed[0];
                this.processPriceUpdate(priceFeed);
                return this.latestPrices.get(priceId);
            }
        } catch (error) {
            logger.error(`Error fetching price for ${priceId}: ${error.message}`);
        }
        return null;
    }
}

export default new PythHermesClient();